[["index.html", "Inverse probability of censoring weights (IPCW) -harjoitus R:llä 1 Alkusanat", " Inverse probability of censoring weights (IPCW) -harjoitus R:llä Ville Langén 19.12.2024 1 Alkusanat Luodaan esimerkkidata ja tehdään siitä survival-analyysi “inverse of the probability of censoring weights (IPCW)” -painotuksella. Käytännössä tehdään sama prosessi mutta isommalla datalla kuin mitä tehtiin artikkelissa Grafféon ja kumppaneiden artikkelissa (PMID: 31442762). Artikkelin koodissa oli joitakin pieniä virheitä, ja koodia piti paikata samaisten henkilöiden tekemästä R:n helppidokumentista. Huom! Nämä koodit ovat lähinnä omaa harjoitteluani varten, joten jos harjoittelet niillä, teet sen omalla vastuullasi. "],["vaaditut-paketit.html", "2 Vaaditut paketit", " 2 Vaaditut paketit Latasin näitä harjoituksia varten seuraavat paketit sessioon. Käytän aina pacmania pakettien latailuun, joten se kannattaa ihan ensiksi asentaa, jos se ei jo ole R:ään asennettuna. library(pacman) p_load(dplyr, dlookr, ipcwswitch, ipw, ggplot2, survival, survminer) "],["esimerkkikoodi.html", "3 Esimerkkikoodi", " 3 Esimerkkikoodi Edellä mainitussa artikkelissa oli vain minimaalinen harjoitusdatasetti, joka näkyy alla. Sen muoto/muuttujat ovat seuraavanlaiset (lähde: Grafféon ym. (PMID: 31442762): This Toy Example Data is given in wide format. It contains the following variables: id is the patient’s identifier, randt is the date of the randomization visit, lastdt is the date of latest news, status is equal to 1 if the patient dies on lastdt (and 0 otherwise), age is the patient’s age, ps1, ps2, ps3 are the values of a covariate measured at dates randt, dt2, dt3, respectively arm is the patient’s randomized arm, swtrtdt is the date when the patient initiates the other arm treatment (NA if does not happen). id randt lastdt status age ps1 ps2 ps3 dt2 dt3 arm swtrtdt 1 2018-01-12 2018-03-02 1 20 0 0 0 2018-02-02 2018-03-01 A 2018-03-01 2 2017-11-04 2017-12-15 1 50 1 NA 2 NA 2017-12-12 B NA 3 2017-05-20 2018-01-04 0 40 0 0 1 2017-08-02 2018-01-02 A NA "],["esimerkkidatan-laajennus.html", "4 Esimerkkidatan laajennus", " 4 Esimerkkidatan laajennus Kopioin manuaalisesti koodin tribbleksi, sen jälkeen lisäsin randomilla dataa, muuttuja kerrallaan, kunnes n oli 400. Esimerkkikoodia ei tarvitse sen enempää opiskella - riittää, että seuraavat rivit kopioi dataansa: toydata &lt;- tibble::tribble( ~id,~randt,~lastdt,~status,~age,~ps1,~ps2,~ps3,~dt2,~dt3,~arm,~swtrtdt, 1L, &quot;12.1.2018&quot;, &quot;2.3.2018&quot;, 1L, 20L, 0L, 0L, 0L, &quot;2.2.2018&quot;, &quot;1.3.2018&quot;, &quot;A&quot;, &quot;1.3.2018&quot;, 2L, &quot;4.11.2017&quot;, &quot;15.12.2017&quot;, 1L, 50L, 1L, 1L, 2L, &quot;1.12.2017&quot;, &quot;12.12.2017&quot;, &quot;B&quot;, NA, 3L, &quot;20.5.2017&quot;, &quot;4.1.2018&quot;, 0L, 40L, 0L, 0L, 1L, &quot;2.8.2017&quot;, &quot;2.1.2018&quot;, &quot;A&quot;, NA ) # konvertoidaan pvm-sarakkeet oikeasti date-muotoisiksi: toydata$randt &lt;- as.Date(toydata$randt, &quot;%d.%m.%Y&quot;) toydata$lastdt &lt;- as.Date(toydata$lastdt, &quot;%d.%m.%Y&quot;) toydata$dt2 &lt;- as.Date(toydata$dt2, &quot;%d.%m.%Y&quot;) toydata$dt3 &lt;- as.Date(toydata$dt3, &quot;%d.%m.%Y&quot;) toydata$swtrtdt &lt;- as.Date(toydata$swtrtdt, &quot;%d.%m.%Y&quot;) # konvertoidaan arm-sarake factor-muotoon: toydata$arm &lt;- as.factor(toydata$arm) # Luodaan lisää random-dataa. # # Ensin lisää tutkittavia (= id-numeroita) siten, että n=400: toydata &lt;- toydata %&gt;% add_row(id = 4:400) # &quot;Uusille&quot; tutkittaville pvm, jolloin randomoitu mukaan tutkimukseen: toydata$randt[4:400] &lt;- toydata$randt[1] + sample(1:30, 397, replace = T) # Uusille tutkittaville ensimmäinen &quot;labrakontrollipvm&quot;, # muotoa randomointi-pvm + 60 + 1-30: toydata &lt;- toydata %&gt;% mutate(dt2 = case_when(is.na(dt2) ~ toydata$randt + 60 + sample(1:30, 400, replace = T), !is.na(dt2) ~ dt2)) # Uusille tutkittaville toinen &quot;labrakontrollipvm&quot;, # muotoa randomointi-pvm + 100 + 1-30: toydata &lt;- toydata %&gt;% mutate(dt3 = case_when(is.na(dt3) ~ toydata$randt + 100 + sample(1:30, 400, replace = T), !is.na(dt3) ~ dt3)) # Uusille tutkittaville pvm, jolloin viimeksi potilaasta kuultiin, # muotoa randomointi-pvm + 150 + 1-30: toydata &lt;- toydata %&gt;% mutate(lastdt = case_when(is.na(lastdt) ~ toydata$randt + 150 + sample(1:300, 400, replace = T), !is.na(lastdt) ~ lastdt)) # Uusille tutkittaville puuttuvat &quot;labratulokset&quot; (kovariaatit): toydata$ps1[4:400] &lt;- sample(0:2, 397, replace = T) toydata$ps2[4:400] &lt;- sample(0:2, 397, replace = T) toydata$ps3[4:400] &lt;- sample(0:2, 397, replace = T) # Uusille tutkittaville arm-arvot (A vs. B): toydata$arm[4:400] &lt;- sample(c(&quot;A&quot;,&quot;B&quot;), 397, replace = TRUE) # Uusille tutkittaville random-iät: toydata$age[4:400] &lt;- sample(20:50, 397, replace = T) # Seuraavaksi uusille tutkittaville pvm, # jolloin mahdollisesti siirtyivät toiseen tutkimus-armiin # Laitetaan kuitenkin näitä siirtyjiä vain armiin &quot;A&quot;, # jotta näemme, toimiiko painotus. # Ensin random-apumuuttuja: jos saa arvon 3, # tutkittava vaihtaa ryhmää kesken tutkimuksen: toydata$apumuuttuja &lt;- sample(1:3, 400, replace = T) toydata &lt;- toydata %&gt;% mutate(swtrtdt = case_when(apumuuttuja == 3 &amp; arm ==&quot;A&quot; ~ toydata$lastdt - sample(1:3, 400, replace = T))) # Kuvitellaan asetelma, jossa armissa &quot;A&quot; myös henkilöitä kuolee enemmän. toydata[4:400,] &lt;- toydata[4:400,] %&gt;% mutate(status = case_when(apumuuttuja == 1 &amp; arm ==&quot;A&quot; ~ 1, apumuuttuja == 2 &amp; arm ==&quot;A&quot; ~ 1, apumuuttuja == 3 &amp; arm ==&quot;A&quot; ~ 0, apumuuttuja == 1 &amp; arm ==&quot;B&quot; ~ 1, apumuuttuja == 2 &amp; arm ==&quot;B&quot; ~ 0, apumuuttuja == 3 &amp; arm ==&quot;B&quot; ~ 0 )) # Yritetään antaa kaikille samat arvot eri aikapisteiden ps-kovariaattiin ihan testiksi: toydata$ps1 &lt;- 1 toydata$ps2 &lt;- 1 toydata$ps3 &lt;- 1 # ipswswitch nikottelee tibblejen kanssa, # joten on muutettava datasettimme data.frame-muotoon: toydata &lt;- as.data.frame(toydata) "],["esimerkkidatan-silmäily.html", "5 Esimerkkidatan silmäily 5.1 Esimerkkidatan struktuuri", " 5 Esimerkkidatan silmäily Silmäillään hieman esimerkkidataa, varmistetaan, että kaikki kunnossa. Katsotaan head-komennolla 10 ensimmäistä riviä: id randt lastdt status age ps1 ps2 ps3 dt2 dt3 arm swtrtdt apumuuttuja 1 2018-01-12 2018-03-02 1 20 1 1 1 2018-02-02 2018-03-01 A NA 1 2 2017-11-04 2017-12-15 1 50 1 1 1 2017-12-01 2017-12-12 B NA 3 3 2017-05-20 2018-01-04 0 40 1 1 1 2017-08-02 2018-01-02 A 2018-01-01 3 4 2018-02-06 2018-09-06 1 42 1 1 1 2018-04-20 2018-06-05 B NA 1 5 2018-01-14 2019-01-10 1 38 1 1 1 2018-04-14 2018-04-26 A NA 1 6 2018-01-19 2018-10-03 1 46 1 1 1 2018-04-12 2018-05-24 A NA 1 5.1 Esimerkkidatan struktuuri On parasta katsoa myös esimerkkidatan struktuuri. ipswswitch nikottelee heti vastaan, jos esim. kvalitatiiviset muuttujat eivät ole tyyppiä factor. Kaikki näyttää alla olevassa listauksessa olevan kunnossa. str(toydata) ## &#39;data.frame&#39;: 400 obs. of 13 variables: ## $ id : int 1 2 3 4 5 6 7 8 9 10 ... ## $ randt : Date, format: &quot;2018-01-12&quot; &quot;2017-11-04&quot; &quot;2017-05-20&quot; ... ## $ lastdt : Date, format: &quot;2018-03-02&quot; &quot;2017-12-15&quot; &quot;2018-01-04&quot; ... ## $ status : int 1 1 0 1 1 1 0 0 1 0 ... ## $ age : int 20 50 40 42 38 46 40 33 23 34 ... ## $ ps1 : num 1 1 1 1 1 1 1 1 1 1 ... ## $ ps2 : num 1 1 1 1 1 1 1 1 1 1 ... ## $ ps3 : num 1 1 1 1 1 1 1 1 1 1 ... ## $ dt2 : Date, format: &quot;2018-02-02&quot; &quot;2017-12-01&quot; &quot;2017-08-02&quot; ... ## $ dt3 : Date, format: &quot;2018-03-01&quot; &quot;2017-12-12&quot; &quot;2018-01-02&quot; ... ## $ arm : Factor w/ 2 levels &quot;A&quot;,&quot;B&quot;: 1 2 1 2 1 1 2 2 2 2 ... ## $ swtrtdt : Date, format: NA NA &quot;2018-01-01&quot; ... ## $ apumuuttuja: int 1 3 3 1 1 1 3 2 1 3 ... "],["timestokeep-komento.html", "6 timesTokeep()-komento", " 6 timesTokeep()-komento Survival-analyysi valmistellaan ensin timesTokeep-komennolla käsittelyllä. Seuraavaksi ajetaan laajennettu toydata monen eri esivaiheen kautta, jotta sille voidaan lopuksi laskea painotukset ja tehdä aivan lopuksi analyysit. kept.t &lt;- timesTokeep(toydata, id = &quot;id&quot;, tstart = &quot;randt&quot;, tstop = &quot;lastdt&quot;, mes.cov = list(c(&quot;ps1&quot;, &quot;ps2&quot;, &quot;ps3&quot;)), time.cov = list(c(&quot;randt&quot;, &quot;dt2&quot;, &quot;dt3&quot;))) Esimerkiksi tutkittavan id=3 päivämäärät näyttävät seuraavalta: kept.t[[1]][[3]] ## [1] &quot;2017-05-20&quot; &quot;2018-01-04&quot; "],["long-format--muoto.html", "7 Long format -muoto", " 7 Long format -muoto Long format -muoto aikaansaadaan wideToLongTDC-komennolla: toy.long &lt;- wideToLongTDC(data = toydata, id = &quot;id&quot;, tstart = &quot;randt&quot;, tstop = &quot;lastdt&quot;, event = &quot;status&quot;, bas.cov = c(&quot;age&quot;, &quot;arm&quot;, &quot;swtrtdt&quot;), mes.cov = list(TDconf = c(&quot;ps1&quot;, &quot;ps2&quot;, &quot;ps3&quot;)), time.cov = list(c(&quot;randt&quot;, &quot;dt2&quot;, &quot;dt3&quot;)), times = kept.t[[1]]) Tämän jälkeen data näyttää seuraavalta (tässä näytetään 10 ensimmäistä riviä). Huomaa, että muuttujaan TDconf tallentuu kaikkien kovariaattien ps1, ps2 ja p3 toistetut arvot, aggregaattina. id tstart tstop event age arm swtrtdt TDconf 1 2018-01-12 2018-03-02 1 20 A NA 1 2 2017-11-04 2017-12-15 1 50 B NA 1 3 2017-05-20 2018-01-04 0 40 A 2018-01-01 1 4 2018-02-06 2018-09-06 1 42 B NA 1 5 2018-01-14 2019-01-10 1 38 A NA 1 6 2018-01-19 2018-10-03 1 46 A NA 1 "],["päivämäärien-käsittely.html", "8 Päivämäärien käsittely", " 8 Päivämäärien käsittely Päivämäärät muutetaan numeeriseen muotoon, jolloin tstart-muuttuja pisteessä 0. Tämä tehdään copy-pastettamalla seuraavat rivit koodiin. # Put dates in numeric format with tstart at 0 toy.long$tstart &lt;- as.numeric(toy.long$tstart) toy.long$tstop &lt;- as.numeric(toy.long$tstop) toy.long$swtrtdt &lt;- as.numeric(toy.long$swtrtdt) tabi &lt;- split(toy.long, toy.long$id) L.tabi &lt;- length(tabi) tablist &lt;- lapply(1:L.tabi, function(i){ refstart &lt;- tabi[[i]]$tstart[1] tabi[[i]]$tstart &lt;- tabi[[i]]$tstart - refstart tabi[[i]]$tstop &lt;- tabi[[i]]$tstop - refstart tabi[[i]]$swtrtdt &lt;- tabi[[i]]$swtrtdt - refstart return(tabi[[i]]) }) toy.long &lt;- do.call( rbind, tablist ) "],["ryhmää-vaihtavien-sensorointi.html", "9 Ryhmää vaihtavien sensorointi 9.1 Sensuroinnin vaikutus", " 9 Ryhmää vaihtavien sensorointi Seuraavaksi käsitellään ryhmää vaihtavien tutkittavien sensorointia. Tämä tapahtuu copy-pastettamalla seuraava koodinpätkä mukaan: # Patients are censored when initiating the other arm treatment, that is, at time swtrtdt toy.long2 &lt;- cens.ipw(toy.long, id = &quot;id&quot;, tstart = &quot;tstart&quot;, tstop = &quot;tstop&quot;, event = &quot;event&quot;, arm = &quot;arm&quot;, realtrt = FALSE, censTime =&quot;swtrtdt&quot;) 9.1 Sensuroinnin vaikutus Seuraavassa esitettynä muutamia rivejä datasetistä, ennen (ensimmäinen taulukko) ja jälkeen (jälkimmäinen taulukko) yllä mainitun sensuroinnin. id tstart tstop event age arm swtrtdt TDconf 1 0 49 1 20 A NA 1 2 0 41 1 50 B NA 1 3 0 229 0 40 A 226 1 4 0 212 1 42 B NA 1 5 0 361 1 38 A NA 1 6 0 257 1 46 A NA 1 id tstart tstop event age arm swtrtdt TDconf cens 1 0 49 1 20 A NA 1 0 2 0 41 1 50 B NA 1 0 3 0 226 0 40 A 226 1 1 4 0 212 1 42 B NA 1 0 5 0 361 1 38 A NA 1 0 6 0 257 1 46 A NA 1 0 "],["event-ajat-samaan-dataan.html", "10 Event-ajat samaan dataan", " 10 Event-ajat samaan dataan Painotukset pitää saada kaikille event- ja treatment-sensoroinnin ajoille, joten seuraavat rivit täytyy ajaa. rep.times1 &lt;- unique(c(toy.long2$tstop[toy.long2$cens==1 &amp; toy.long2$arm == &quot;A&quot;], toy.long2$tstop[toy.long2$event==1])) rep.times2 &lt;- unique(c(toy.long2$tstop[toy.long2$cens==1 &amp; toy.long2$arm == &quot;B&quot;], toy.long2$tstop[toy.long2$event==1])) # to put times in same order as arms levels # (Huom. tätä riviä ei ollut referoidussa artikkelissa, # mutta R-dokumentaation mukaan se kannattaa ajaa.) levels(toy.long2[, &quot;arm&quot;]) ## [1] &quot;A&quot; &quot;B&quot; # Now, we can replicate the rows toy.rep &lt;- replicRows(toy.long2, tstart = &quot;tstart&quot;, tstop = &quot;tstop&quot;, event = &quot;event&quot;, cens = &quot;cens&quot;, times1 = rep.times1, times2 = rep.times2, arm = &quot;arm&quot;) Lopputuloksena seuraavan näköinen datasetti: id age arm swtrtdt TDconf cens weights tstart tstop event 1 20 A NA 1 0 0 0 41 0 1 20 A NA 1 0 0 41 49 1 3 40 A 226 1 0 0 0 41 0 3 40 A 226 1 0 0 41 49 0 3 40 A 226 1 0 0 49 154 0 3 40 A 226 1 0 0 154 155 0 "],["painotusten-laskeminen.html", "11 Painotusten laskeminen", " 11 Painotusten laskeminen Tässä vaiheessa päästään vihdoinkin laskemaan painotukset. Painotukset lasketaan komennolla ipcw: toy.rep &lt;- ipcw(toy.rep, id = &quot;id&quot;, tstart = tstart, tstop = tstop, cens = cens, arm = &quot;arm&quot;, bas.cov = c(&quot;age&quot;), conf = c(&quot;TDconf&quot;), trunc = 0.01, type = &#39;kaplan-meier&#39;) Tämä analyysi heittää warningseja runsaasti, mutta ajoin oleellisesti ihan samat analyysit R:n helppidokumentissa käytetyllä esimerkkidatasetillä (data(“SHIdat”)) ja samassa dokumentissa listatulla koodilla läpi, ja aivan samantyyppiset warningit näyttivät silläkin tulevan. Saadaan aikaiseksi seuraavalta näyttävä datasetti: id age arm swtrtdt TDconf cens weights tstart tstop event weights.trunc 1 20 A NA 1 0 1 0 41 0 1 1 20 A NA 1 0 1 41 49 1 1 3 40 A 226 1 0 1 0 41 0 1 3 40 A 226 1 0 1 41 49 0 1 3 40 A 226 1 0 1 49 154 0 1 3 40 A 226 1 0 1 154 155 0 1 "],["painotusten-plottaaminen.html", "12 Painotusten plottaaminen", " 12 Painotusten plottaaminen Luodut painotukset pystyy tämän jälkeen plottaamaan seuraavasti. (Allekirjoittaneelle on epäselvää, kuinka yleistä on, että näitä julkaistaan esim. supplemental-osuudessa.) Un-truncated stabilized weights: ipwplot(weights = toy.rep$weights, timevar = toy.rep$tstart, binwidth = 50, logscale = T, xlab = &quot;Time since enrolment (days)&quot;, ylab = &quot;Logarithm of the stabilized\\n un-truncated weights&quot;) Truncated stabilized weights: ipwplot(weights = toy.rep$weights, timevar = toy.rep$tstart, binwidth = 50, logscale = T, xlab = &quot;Time since enrolment (days)&quot;, ylab = &quot;Logarithm of the stabilized\\n un-truncated weights&quot;) "],["coxin-msm-mallin-kokoaminen.html", "13 Coxin MSM-mallin kokoaminen", " 13 Coxin MSM-mallin kokoaminen Nyt kun painotukset on vihdoin viimein saatu laskettua, ne saadaan otettua Coxin MSM-malliin (marginal structural models) mukaan. Käytetään coxph-funktiota paketista survival, ja painotukset määritetään funktion argumenteissa. Truncated stabilized weights: fit.stab.w &lt;- coxph(Surv(tstart, tstop, event) ~ age + arm + cluster(id), data = toy.rep, weights = toy.rep$weights.trunc) Mallin tulos saadaan laajemmin esiin komennolla summary: summary(fit.stab.w) ## Call: ## coxph(formula = Surv(tstart, tstop, event) ~ age + arm, data = toy.rep, ## weights = toy.rep$weights.trunc, cluster = id) ## ## n= 30546, number of events= 193 ## ## coef exp(coef) se(coef) robust se z Pr(&gt;|z|) ## age 0.009342 1.009385 0.007677 0.008020 1.165 0.244 ## armB -0.619033 0.538465 0.151447 0.149963 -4.128 3.66e-05 *** ## --- ## Signif. codes: 0 &#39;***&#39; 0.001 &#39;**&#39; 0.01 &#39;*&#39; 0.05 &#39;.&#39; 0.1 &#39; &#39; 1 ## ## exp(coef) exp(-coef) lower .95 upper .95 ## age 1.0094 0.9907 0.9936 1.0254 ## armB 0.5385 1.8571 0.4013 0.7224 ## ## Concordance= 0.584 (se = 0.024 ) ## Likelihood ratio test= 19.29 on 2 df, p=6e-05 ## Wald test = 18.36 on 2 df, p=1e-04 ## Score (logrank) test = 19.05 on 2 df, p=7e-05, Robust = 19.06 p=7e-05 ## ## (Note: the likelihood ratio and score tests assume independence of ## observations within a cluster, the Wald and robust score tests do not). "],["survival-käyrä-kaikki-tutkittavat.html", "14 Survival-käyrä: kaikki tutkittavat", " 14 Survival-käyrä: kaikki tutkittavat Survival-käyrän plottaamista ei käsitelty yllä referoidussa lähdeartikkelissa. Sain kuitenkin käyrää aikaiseksi kaikkien tutkittavien ryhmästä (sekä arm A että B) seuraavalla tavalla: fit_all &lt;- survfit(fit.stab.w) ggsurvplot(fit_all, data=toydata, color = &quot;#2E9FDF&quot;, ggtheme = theme_minimal()) ## Warning: Now, to change color palette, use the argument palette= &#39;#2E9FDF&#39; instead of color = ## &#39;#2E9FDF&#39; "],["survival-käyrä-arm-a-ja-b.html", "15 Survival-käyrä: arm A ja B", " 15 Survival-käyrä: arm A ja B Erityistä pohdintaa aiheutti tässä otsikossa esitetty kysymys. Ryhmien erottamiseksi toisistaan omiksi survival-käyrikseen täytyy käsitykseni mukaan tehdä “apu-dataframe”, johon kuvaillaan millintarkasti, mitä muuttujia tahdotaan plotata. Jos ja kun erotellaan ryhmät erikseen, pitää niiden levelien olla millintarkasti plotattavaa datasettiä vastaavat, ja kyseinen apumuuttuja täytyy muuttaa factor-muotoon. Jos joukossa on muita kovariaatteja, niiden meania käytetään survival-käyrän mallissa: # Apudatasetin luominen apudf &lt;- with(toydata, data.frame(arm = c(&quot;A&quot;, &quot;B&quot;), age = rep(mean(age, na.rm = TRUE), 2))) apudf$arm &lt;- as.factor(apudf$arm) apudf ## arm age ## 1 A 35.015 ## 2 B 35.015 fit2 &lt;- survfit(fit.stab.w, newdata = apudf) ggsurvplot(fit2, data=toydata, conf.int = TRUE, legend.labs=c(&quot;Arm = A&quot;, &quot;Arm = B&quot;), ggtheme = theme_minimal()) "],["koko-koodi.html", "16 Koko koodi", " 16 Koko koodi Alla on näkyvissä tässä harjoituksessa esitellyt koodit yhtenä putkena, jolloin ne kaikki voidaan ajaa kerralla. # Load packages library(pacman) p_load(dplyr, dlookr, ipcwswitch, ipw, ggplot2, survival, survminer) # Display toydata knitr::kable(ipcwswitch::toydata) # Esimerkkikoodin laajennus ad n=400 toydata &lt;- tibble::tribble( ~id,~randt,~lastdt,~status,~age,~ps1,~ps2,~ps3,~dt2,~dt3,~arm,~swtrtdt, 1L, &quot;12.1.2018&quot;, &quot;2.3.2018&quot;, 1L, 20L, 0L, 0L, 0L, &quot;2.2.2018&quot;, &quot;1.3.2018&quot;, &quot;A&quot;, &quot;1.3.2018&quot;, 2L, &quot;4.11.2017&quot;, &quot;15.12.2017&quot;, 1L, 50L, 1L, 1L, 2L, &quot;1.12.2017&quot;, &quot;12.12.2017&quot;, &quot;B&quot;, NA, 3L, &quot;20.5.2017&quot;, &quot;4.1.2018&quot;, 0L, 40L, 0L, 0L, 1L, &quot;2.8.2017&quot;, &quot;2.1.2018&quot;, &quot;A&quot;, NA ) # Konvertoidaan pvm-sarakkeet oikeasti date-muotoisiksi: toydata$randt &lt;- as.Date(toydata$randt, &quot;%d.%m.%Y&quot;) toydata$lastdt &lt;- as.Date(toydata$lastdt, &quot;%d.%m.%Y&quot;) toydata$dt2 &lt;- as.Date(toydata$dt2, &quot;%d.%m.%Y&quot;) toydata$dt3 &lt;- as.Date(toydata$dt3, &quot;%d.%m.%Y&quot;) toydata$swtrtdt &lt;- as.Date(toydata$swtrtdt, &quot;%d.%m.%Y&quot;) # Konvertoidaan arm-sarake factor-muotoon: toydata$arm &lt;- as.factor(toydata$arm) # Luodaan lisää random-dataa. # # Ensin lisää tutkittavia (= id-numeroita) siten, että n=400: toydata &lt;- toydata %&gt;% add_row(id = 4:400) # &quot;Uusille&quot; tutkittaville pvm, jolloin randomoitu mukaan tutkimukseen: toydata$randt[4:400] &lt;- toydata$randt[1] + sample(1:30, 397, replace = T) # Uusille tutkittaville ensimmäinen &quot;labrakontrollipvm&quot;, # muotoa randomointi-pvm + 60 + 1-30: toydata &lt;- toydata %&gt;% mutate(dt2 = case_when(is.na(dt2) ~ toydata$randt + 60 + sample(1:30, 400, replace = T), !is.na(dt2) ~ dt2)) # Uusille tutkittaville toinen &quot;labrakontrollipvm&quot;, # muotoa randomointi-pvm + 100 + 1-30: toydata &lt;- toydata %&gt;% mutate(dt3 = case_when(is.na(dt3) ~ toydata$randt + 100 + sample(1:30, 400, replace = T), !is.na(dt3) ~ dt3)) # Uusille tutkittaville pvm, jolloin viimeksi potilaasta kuultiin, # muotoa randomointi-pvm + 150 + 1-30: toydata &lt;- toydata %&gt;% mutate(lastdt = case_when(is.na(lastdt) ~ toydata$randt + 150 + sample(1:300, 400, replace = T), !is.na(lastdt) ~ lastdt)) # Uusille tutkittaville puuttuvat &quot;labratulokset&quot; (kovariaatit): toydata$ps1[4:400] &lt;- sample(0:2, 397, replace = T) toydata$ps2[4:400] &lt;- sample(0:2, 397, replace = T) toydata$ps3[4:400] &lt;- sample(0:2, 397, replace = T) # Uusille tutkittaville arm-arvot (A vs. B): toydata$arm[4:400] &lt;- sample(c(&quot;A&quot;,&quot;B&quot;), 397, replace = TRUE) # Uusille tutkittaville random-iät: toydata$age[4:400] &lt;- sample(20:50, 397, replace = T) # Seuraavaksi uusille tutkittaville pvm, # jolloin mahdollisesti siirtyivät toiseen tutkimus-armiin # Laitetaan kuitenkin näitä siirtyjiä vain armiin &quot;A&quot;, # jotta näemme, toimiiko painotus. # Ensin random-apumuuttuja: jos saa arvon 3, # tutkittava vaihtaa ryhmää kesken tutkimuksen: toydata$apumuuttuja &lt;- sample(1:3, 400, replace = T) toydata &lt;- toydata %&gt;% mutate(swtrtdt = case_when(apumuuttuja == 3 &amp; arm ==&quot;A&quot; ~ toydata$lastdt - sample(1:3, 400, replace = T))) # Kuvitellaan asetelma, jossa armissa &quot;A&quot; myös henkilöitä kuolee enemmän. toydata[4:400,] &lt;- toydata[4:400,] %&gt;% mutate(status = case_when(apumuuttuja == 1 &amp; arm ==&quot;A&quot; ~ 1, apumuuttuja == 2 &amp; arm ==&quot;A&quot; ~ 1, apumuuttuja == 3 &amp; arm ==&quot;A&quot; ~ 0, apumuuttuja == 1 &amp; arm ==&quot;B&quot; ~ 1, apumuuttuja == 2 &amp; arm ==&quot;B&quot; ~ 0, apumuuttuja == 3 &amp; arm ==&quot;B&quot; ~ 0 )) # Yritetään antaa kaikille samat arvot eri aikapisteiden ps-kovariaattiin ihan testiksi: toydata$ps1 &lt;- 1 toydata$ps2 &lt;- 1 toydata$ps3 &lt;- 1 # ipswswitch nikottelee tibblejen kanssa, # joten on muutettava datasettimme data.frame-muotoon: toydata &lt;- as.data.frame(toydata) # Silmäillään nyt uudelleen toydataa knitr::kable(head(toydata)) # Näytetään toydatan struktuuri str(toydata) # Survival-analyysin valmistelu: ensin *timesTokeep*-komennolla käsittely kept.t &lt;- timesTokeep(toydata, id = &quot;id&quot;, tstart = &quot;randt&quot;, tstop = &quot;lastdt&quot;, mes.cov = list(c(&quot;ps1&quot;, &quot;ps2&quot;, &quot;ps3&quot;)), time.cov = list(c(&quot;randt&quot;, &quot;dt2&quot;, &quot;dt3&quot;))) # Esimerkiksi tutkittavan id=3 päivämäärät näyttävät seuraavalta: kept.t[[1]][[3]] # Seuraavaksi *long format* muotoon muuttaminen toy.long &lt;- wideToLongTDC(data = toydata, id = &quot;id&quot;, tstart = &quot;randt&quot;, tstop = &quot;lastdt&quot;, event = &quot;status&quot;, bas.cov = c(&quot;age&quot;, &quot;arm&quot;, &quot;swtrtdt&quot;), mes.cov = list(TDconf = c(&quot;ps1&quot;, &quot;ps2&quot;, &quot;ps3&quot;)), time.cov = list(c(&quot;randt&quot;, &quot;dt2&quot;, &quot;dt3&quot;)), times = kept.t[[1]]) # Näytetään 10 ensimmäistä riviä knitr::kable(head(toy.long)) # Päivämäärät numeeriseen muotoon, jolloin tstart-muuttuja pisteessä 0 # Put dates in numeric format with tstart at 0 toy.long$tstart &lt;- as.numeric(toy.long$tstart) toy.long$tstop &lt;- as.numeric(toy.long$tstop) toy.long$swtrtdt &lt;- as.numeric(toy.long$swtrtdt) tabi &lt;- split(toy.long, toy.long$id) L.tabi &lt;- length(tabi) tablist &lt;- lapply(1:L.tabi, function(i){ refstart &lt;- tabi[[i]]$tstart[1] tabi[[i]]$tstart &lt;- tabi[[i]]$tstart - refstart tabi[[i]]$tstop &lt;- tabi[[i]]$tstop - refstart tabi[[i]]$swtrtdt &lt;- tabi[[i]]$swtrtdt - refstart return(tabi[[i]]) }) toy.long &lt;- do.call( rbind, tablist ) # Ryhmää vaihtavien tutkittavien sensorointi # Patients are censored when initiating the other arm treatment, that is, at time swtrtdt toy.long2 &lt;- cens.ipw(toy.long, id = &quot;id&quot;, tstart = &quot;tstart&quot;, tstop = &quot;tstop&quot;, event = &quot;event&quot;, arm = &quot;arm&quot;, realtrt = FALSE, censTime =&quot;swtrtdt&quot;) # Datasetti ennen sensurointia ja sen jälkeen knitr::kable(head(toy.long)) knitr::kable(head(toy.long2)) # Kaikkien event-aikojen yhdistäminen yhteen ja samaan dataan rep.times1 &lt;- unique(c(toy.long2$tstop[toy.long2$cens==1 &amp; toy.long2$arm == &quot;A&quot;], toy.long2$tstop[toy.long2$event==1])) rep.times2 &lt;- unique(c(toy.long2$tstop[toy.long2$cens==1 &amp; toy.long2$arm == &quot;B&quot;], toy.long2$tstop[toy.long2$event==1])) # to put times in same order as arms levels # (Huom. tätä riviä ei ollut referoidussa artikkelissa, # mutta R-dokumentaation mukaan se kannattaa ajaa.) levels(toy.long2[, &quot;arm&quot;]) # Now, we can replicate the rows toy.rep &lt;- replicRows(toy.long2, tstart = &quot;tstart&quot;, tstop = &quot;tstop&quot;, event = &quot;event&quot;, cens = &quot;cens&quot;, times1 = rep.times1, times2 = rep.times2, arm = &quot;arm&quot;) # Lopputuloksena seuraavan näköinen datasetti: knitr::kable(head(toy.rep)) # Vihdoinkin painotusten laskeminen # Painotukset lasketaan komennolla *ipcw*: toy.rep &lt;- ipcw(toy.rep, id = &quot;id&quot;, tstart = tstart, tstop = tstop, cens = cens, arm = &quot;arm&quot;, bas.cov = c(&quot;age&quot;), conf = c(&quot;TDconf&quot;), trunc = 0.01, type = &#39;kaplan-meier&#39;) # Tarkastellaan taas dataa knitr::kable(head(toy.rep)) # Painotusten distribuution plottaaminen ipwplot(weights = toy.rep$weights, timevar = toy.rep$tstart, binwidth = 50, logscale = T, xlab = &quot;Time since enrolment (days)&quot;, ylab = &quot;Logarithm of the stabilized\\n un-truncated weights&quot;) #Truncated stabilized weights: ipwplot(weights = toy.rep$weights, timevar = toy.rep$tstart, binwidth = 50, logscale = T, xlab = &quot;Time since enrolment (days)&quot;, ylab = &quot;Logarithm of the stabilized\\n un-truncated weights&quot;) # Lopultakin Coxin MSM-mallin kokoaminen painotusten kera # Truncated stabilized weights: fit.stab.w &lt;- coxph(Surv(tstart, tstop, event) ~ age + arm + cluster(id), data = toy.rep, weights = toy.rep$weights.trunc) # Summary mallista summary(fit.stab.w) # Survival-käyrän plottaaminen - tutkimuksen koko populaatio fit_all &lt;- survfit(fit.stab.w) ggsurvplot(fit_all, data=toydata, color = &quot;#2E9FDF&quot;, ggtheme = theme_minimal()) # Survival-käyrän plottaaminen erikseen arm A:sta ja B:stä # Apudatasetin luominen apudf &lt;- with(toydata, data.frame(arm = c(&quot;A&quot;, &quot;B&quot;), age = rep(mean(age, na.rm = TRUE), 2))) apudf$arm &lt;- as.factor(apudf$arm) apudf fit2 &lt;- survfit(fit.stab.w, newdata = apudf) ggsurvplot(fit2, data=toydata, conf.int = TRUE, legend.labs=c(&quot;Arm = A&quot;, &quot;Arm = B&quot;), ggtheme = theme_minimal()) "],["404.html", "Page not found", " Page not found The page you requested cannot be found (perhaps it was moved or renamed). You may want to try searching to find the page's new location, or use the table of contents to find the page you are looking for. "]]
